%!TEX root = ../Thesis.tex
Basic approaches such as A* solve the problem for single agents, but cannot be used in a multi-agent approach without modifications. The reason is that a multi-agent scenario is more dynamic and agents have to avoid collision with each other so it is not enough to just plan a simple route for every agent separately. Computing power is often an additional constraint, as an agent is usually a computer or robot with limited resources. Therefore it is beneficial if agents are cooperating with each other. Most of the algorithms used in this setup are based on A* with tweaks that allow multi-agent cooperation \cite{path_adv}.

Multi-agent path-finding can be classified into two categories: collaborative and non-collaborative. In the collaborative approach, it is assumed that all agents have full knowledge of all the others whereas in the non-collaborative it must predict the movement of the other agents as it has limited knowledge. This thesis will mostly focus on the former. 

Among multiple path-planning algorithms, CA* (pronounced CA star) was selected for implementation, because it is based on the widely used A* algorithm, which has a simple and well-understood structure. Additionally, the collaborative aspect of the algorithm can be implemented using standard communication protocols, making it a straightforward task to integrate the algorithm into a multi-agent system. Another reason is that CA* is not highly efficient, which can be useful in certain scenarios. Specifically, if the goal is to understand and analyze the behavior of a multi-agent system, a less efficient algorithm can provide more insight into the system's workings. Additionally, the algorithm can be useful for scenarios where computational resources are limited.

\subsection{Colaborative A*}
The Cooperative A*(CA*) algorithm is also divided into a smaller number of individual agent searches, but it takes into consideration the routes of other agents. It uses a 3-dimensional representation of a time-space map. Usually two dimensions are storing the location of the agents and 3rd one represents the time frame, this structure is called the reservation table. The table is shared between the agents so they can mark the other agents as obstacles at any given time to avoid collision \cite{path_adv}. 

The problem with this approach is that the routes have to be calculated in a sequence in 3-dimensional space which can slow down the execution of the algorithm and increase the level of coordination between agents as they have to agree on the sequence of calculation. Moreover, it might not be ideal for a cloud collaborative approach as even an agent with more computational power will not be able to solve the task more efficiently as it has to invoke computations in a sequence.

The algorithm works the same as the original A*, the only differences are the creation of the grid map which is now 3 dimensional, and  performing of the computation in sequence. Grid map has to be constructed in a way to disallow agents to move backward along the z-axis which symbolizes time. To achieve that nodes of graphs have to be connected only in one direction. More information about the structure of the map and the connection between the nodes can be found in section \ref{sec:03_06_Map_Design}.

\subsection{Windowed Hierarchical Cooperative A*}
Previous algorithms have operated under the assumption that once an agent reaches its designated goal, it should cease movement. However, this approach can lead to edge cases in which agents may block the path of other agents. The Windowed Hierarchical Cooperative A*(WHCA*) algorithm addresses this issue by permitting agents to continue moving after their routes have been calculated. Furthermore, this algorithm utilizes a dynamic ordering of agents, in which the priority of each agent is continually reassessed, allowing for every agent to have the highest priority at a given point in time.

One of the limitations of prior algorithms is the challenge of planning in large three-dimensional spaces. To address this, the algorithm employs a technique known as windowed search, which reduces the complexity of the search process. In this approach, each agent plans a partial route to its goal by first planning the full route without considering the presence of other agents and then dividing it into smaller, "windowed" goals. Interactions between agents are only considered at the level of these windows, which leads to a reduction in computational demands. Additionally, the window is moved in a specific manner, for instance, if an agent is halfway through the window. The objective for each agent becomes to complete the assigned window without collision with other agents \cite{whca}\cite{path_adv}.

The utilization of windowing in the algorithm allows for a more efficient division of calculations, as only one window needs to be computed at a time. This enables agents to proceed to the computation of the next window while other agents are still working on the previous one. This allows for distributed, efficient computation of the path and the possibility of offloading some of the work to external agents such as cloud computing. However, the introduction of these enhancements also increases the complexity and difficulty of implementing the algorithm.


\subsection{Fast and Memory-Efficient Multi-Agent algorithm}
The Fast and Memory-Efficient Multi-Agent algorithm(FAR) is a method that utilizes the concept of flow restriction areas inspired by road networks. It limits the movement of agents to only horizontal or vertical directions within a single column or row, in order to prevent head-to-head collisions. Using this approach, the algorithm constructs a graph and performs A* search for each agent independently, disregarding the presence of other agents.

Deadlocks and cycles are then resolved locally in order to avoid costly re-planning. This algorithm operates under the assumption that all rows and columns are one-directional and that head-to-head collisions are not possible. This simplifies the process of resolving side-collision situations, as specific sequences of movements can be implemented to break out of collision situations. The algorithm is designed to be scalable and has low compute and memory requirements. Its implementation is simple and efficient as it uses a normal graph representation \cite{far}.

\subsection{Multi-agent Path Planning algorithm}
The Multi-Agent Path Planning algorithm(MAPP) is a method that, in contrast to previously mentioned algorithms, is able to avoid deadlocks and cycles through the use of a special ordering of agents. The algorithm begins by computing a path to the goal for each agent, while simultaneously computing and caching alternative paths that meet the requirement of being "SLIDABLE" \cite{mapp_algo}. 

The algorithm divides the set of agents into two categories: solved and active units. Initially, all agents are considered active, and once an agent reaches its goal, it is marked as solved and no longer considered in the resolution of the problem. The algorithm then proceeds by iterating through progression steps to move active agents towards their goals, with each progression step resulting in at least one active agent reaching its target. However, as the progression step may violate the necessary conditions, a repositioning step is subsequently executed. Once all agents have reached their targets, the algorithm terminates \cite{mapp_algo}.